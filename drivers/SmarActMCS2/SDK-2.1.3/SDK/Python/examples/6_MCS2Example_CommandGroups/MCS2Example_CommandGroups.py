#!/usr/bin/python3
import sys
import smaract.ctl as ctl

# SmarAct MCS2 programming example: Command Groups
#
# This programming example shows how to use command groups
# to atomic group MCS2 properties and commands.
# For a full command reference see the MCS2 Programmers Guide.

def assert_lib_compatibility():
    """
    Checks that the major version numbers of the Python API and the
    loaded shared library are the same to avoid errors due to 
    incompatibilities.
    Raises a RuntimeError if the major version numbers are different.
    """
    vapi = ctl.api_version
    vlib = [int(i) for i in ctl.GetFullVersionString().split('.')]
    if vapi[0] != vlib[0]:
        raise RuntimeError("Incompatible SmarActCTL python api and library version.")

def waitForEvent():
    """ Wait for events generated by the connected device """
    # The wait for event function blocks until an event was received or the timeout elapsed.
    # In case of timeout, a "ctl.Error" exception is raised containing the "TIMEOUT" error.
    # For this example we are only interested in "CMD_GROUP_TRIGGERED" events
    # thus we drop all other events like "MOVEMENT_FINISHED" etc.
    timeout = 10000 # in ms
    done = False
    while (not done):
        try:
            event = ctl.WaitForEvent(d_handle, timeout)
            # The "type" field specifies the event.
            # The "idx" field holds the device index for this event, it will always be "0", thus might be ignored here.
            # The "i32" data field gives additional information about the event.
            if event.type == ctl.EventType.CMD_GROUP_TRIGGERED:
                # A command group has been executed.
                # The event parameter holds:
                # - the result code of the group (Bit 0-15)
                # - the corresponding transmit handle of the group (Bit 31-24)
                t_handle = ctl.EventParameter.PARAM_HANDLE(event.i32)
                result_code = ctl.EventParameter.PARAM_RESULT(event.i32)
                if result_code == ctl.ErrorCode.NONE:
                    print("MCS2 command group triggered, handle: {}".format(t_handle))
                else:
                    # The command group failed -> the reason may be found in the result code.
                    # To determine which command caused the error, read the individual results of the command
                    # with "WaitForWrite" / "ReadProperty_x".
                    print("MCS2 command group failed, handle: {}, error: 0x{:04X} ({})".format(t_handle, result_code, ctl.GetResultInfo(result_code)))
                done = True
            else:
                # ignore other events and wait for the next one
                pass
        except ctl.Error as e:
            if e.code == ctl.ErrorCode.TIMEOUT:
                print("MCS2 wait for event timed out after {} ms".format(timeout))
            else:
                print("MCS2 {}".format(ctl.GetResultInfo(e.code)))
            return

print("*******************************************************")
print("*  SmarAct MCS2 Programming Example (Command Groups)  *")
print("*******************************************************")

# Read the version of the library
# Note: this is the only function that does not require the library to be initialized.
version = ctl.GetFullVersionString()
print("SmarActCTL library version: '{}'.".format(version))
assert_lib_compatibility()

# Find available MCS2 devices
try:
    buffer = ctl.FindDevices()
    if len(buffer) == 0:
        print("MCS2 no devices found.")
        sys.exit(1)
    locators = buffer.split("\n")
    for locator in locators:
        print("MCS2 available devices: {}".format(locator))
except:
    print("MCS2 failed to find devices. Exit.")
    input()
    sys.exit(1)

d_handle = None
try:
    # Open the first MCS2 device from the list
    d_handle = ctl.Open(locators[0])
    print("MCS2 opened {}.".format(locators[0]))

    # Command groups offer the possibility to define an atomic group of commands that is executed
    # synchronously. In addition, a command group may not only be triggered via software,
    # but alternatively via an external trigger.
    # Several properties and movement commands can be set atomic for one or more channels.

    # A typical set of properties and commands may be:
    # - set property : move mode
    # - set property : move velocity
    # - move
    # To define a command group simply surround the commands that should be grouped with calls
    # to the OpenCommandGroup and CloseCommandGroup functions and pass
    # the transmit handle received from the OpenCommandGroup function to all commands
    # to be grouped.

    # Events must be used to get status information in the context of command groups.
    # A CMD_GROUP_TRIGGERED event notifies the software that the grouped commands
    # are processed.
    # Note that movement commands do not generate a result packet. Instead a
    # MOVEMENT_FINISHED event is generated once the command finished.

    # The following code configures two channels for a closed loop movement and then moves both
    # channels to some target position. The grouped commands and properties are treated as one command
    # and the movement of both channels start synchronously.
    # (in this case as soon as the command group is closed, since the direct trigger mode is used).
    r_id = [0]*6
    # First enable the amplifiers of both channels
    print("*******************************************************")
    print("-> Press return to start command group (amplifier enable).")
    input()
    t_handle = ctl.OpenCommandGroup(d_handle, ctl.CmdGroupTriggerMode.DIRECT)

    r_id[0] = ctl.RequestWriteProperty_i32(d_handle, 0, ctl.Property.AMPLIFIER_ENABLED,
                                          ctl.TRUE, tHandle=t_handle)

    r_id[1] = ctl.RequestWriteProperty_i32(d_handle, 1, ctl.Property.AMPLIFIER_ENABLED,
                                          ctl.TRUE, tHandle=t_handle)

    ctl.CloseCommandGroup(d_handle, t_handle)

    # Wait for the "triggered" event before reading the results
    waitForEvent()
    # One important thing to notice is that the WaitForWrite function calls must be issued
    # after the command group was closed. Otherwise the function calls will block.
    # Note that synchronous property accesses cannot be put into a command group.
    ctl.WaitForWrite(d_handle, r_id[0])
    ctl.WaitForWrite(d_handle, r_id[1])

    print("*******************************************************")
    print("-> Press return to start command group (movement).")
    input()

    t_handle = ctl.OpenCommandGroup(d_handle, ctl.CmdGroupTriggerMode.DIRECT)

    r_id[0] = ctl.RequestWriteProperty_i32(d_handle, 0, ctl.Property.MOVE_MODE,
                                             ctl.MoveMode.CL_ABSOLUTE, tHandle=t_handle)
    r_id[1] = ctl.RequestWriteProperty_i32(d_handle, 1, ctl.Property.MOVE_MODE,
                                             ctl.MoveMode.CL_ABSOLUTE, tHandle=t_handle)
    r_id[2] = ctl.RequestWriteProperty_i64(d_handle, 0, ctl.Property.MOVE_VELOCITY,
                                             1000000000, tHandle=t_handle)
    r_id[3] = ctl.RequestWriteProperty_i64(d_handle, 1, ctl.Property.MOVE_VELOCITY,
                                             1000000000, tHandle=t_handle)
    r_id[4] = ctl.RequestWriteProperty_i64(d_handle, 0, ctl.Property.MOVE_ACCELERATION,
                                             10000000000, tHandle=t_handle)
    r_id[5] = ctl.RequestWriteProperty_i64(d_handle, 1, ctl.Property.MOVE_ACCELERATION,
                                             10000000000, tHandle=t_handle)
    ctl.Move(d_handle, 0, 1000000000, t_handle)
    ctl.Move(d_handle, 1, 2000000000, t_handle)

    ctl.CloseCommandGroup(d_handle, t_handle)

    # Wait for the "triggered" event before reading the results
    waitForEvent()
    for id in r_id:
        ctl.WaitForWrite(d_handle, id)

    print("*******************************************************")
    print("-> Press return to read the position.")
    input()

    # Next we create a command group to read some properties: the current position of both channels.
    t_handle = ctl.OpenCommandGroup(d_handle, ctl.CmdGroupTriggerMode.DIRECT)

    r_id[0] = ctl.RequestReadProperty(d_handle, 0, ctl.Property.POSITION, t_handle)
    r_id[1] = ctl.RequestReadProperty(d_handle, 1, ctl.Property.POSITION, t_handle)

    ctl.CloseCommandGroup(d_handle, t_handle)

    # Wait for the "triggered" event before reading the results
    waitForEvent()
    # The same rule applies as for write properties:
    # Put the RequestReadProperty calls into the command group,
    # but issue e.g. ReadProperty_i64 calls after the group close.
    position_0 = ctl.ReadProperty_i64(d_handle, r_id[0])
    position_1 = ctl.ReadProperty_i64(d_handle, r_id[1])

    print("Position channel 0: {} pm, channel 1: {} pm.".format(position_0, position_1))
    input()

except ctl.Error as e:
    # Passing an error code to "GetResultInfo" returns a human readable string
    # specifying the error.
    print("MCS2 {}: {}, error: {} (0x{:04X}) in line: {}."
          .format(e.func, ctl.GetResultInfo(e.code), ctl.ErrorCode(e.code).name, e.code, (sys.exc_info()[-1].tb_lineno)))

except Exception as ex:
    print("Unexpected error: {}, {} in line: {}".format(ex, type(ex), (sys.exc_info()[-1].tb_lineno)))
    raise

finally:
    # Before closing the program the connection to the device must be closed by calling "Close".
    if d_handle != None:
        ctl.Close(d_handle)
    print("MCS2 close.")
    print("*******************************************************")
    print("Done. Press return to exit.")
    input()